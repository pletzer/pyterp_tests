program ESMF_FileRegridWFDemo

  use ESMF
  use ESMF_RegridWeightGenMod
  implicit none

  ! --------------------------------------------------------------------------------
  ! Modifiable program arguments.

  character(len=*), parameter :: srcFilenameTemplate = 'data/src_split_'
  character(len=*), parameter :: dstFilenameTemplate = 'data/dst_split_'
  character(len=*), parameter :: weightFilenameTemplate = 'data/esmf_weights_'
  character(len=*), parameter :: srcVarname = 'exact'
  character(len=*), parameter :: dstVarname = 'exact'
  ! Set this to the file count generated by the splitting utility.
  integer, parameter :: fileIndexStop = 100

  ! Set to .false. to not create weight files.
  logical, parameter :: createWeightFile = .true.
  ! Set to .false. to not perform sparse matrix multiplication. This step also
  ! inserts the weighted data.
  logical, parameter :: arraySMM = .true.

  type(ESMF_FileFormat_Flag), parameter :: fileFormat = ESMF_FILEFORMAT_GRIDSPEC

  type(ESMF_RegridMethod_Flag), parameter :: regridmethod = ESMF_REGRIDMETHOD_BILINEAR
!  type(ESMF_RegridMethod_Flag), parameter :: regridmethod = ESMF_REGRIDMETHOD_CONSERVE

  type(ESMF_UnmappedAction_Flag), parameter :: unmappedaction = ESMF_UNMAPPEDACTION_IGNORE
!  type(ESMF_UnmappedAction_Flag), parameter :: unmappedaction = ESMF_UNMAPPEDACTION_ERROR

  type(ESMF_Region_Flag), parameter :: zeroregion = ESMF_REGION_SELECT

!  logical, parameter :: ignoreDegenerate = .false.
  logical, parameter :: ignoreDegenerate = .true.

  ! Value used to fill the destination array before weighting the source data.
  real, parameter :: dstFillValue = 1e20

  ! Set this to adjust the start file index. Useful if there is a failure in the
  ! middle of processing files.
  integer, parameter :: fileIndexStart = 1
  integer, parameter :: skipUntil = 1
  logical, parameter :: verbose = .true.
  logical, parameter :: netcdf4fileFlag = .true.

  ! --------------------------------------------------------------------------------
  ! Do not modify these variables.

  integer :: rc, localPet, petCount, ii
  type(ESMF_VM) :: vm
  character(len=ESMF_MAXSTR) :: weightFilename, srcFilename, dstFilename
  character(len=ESMF_MAXSTR), allocatable, dimension(:) :: weightFilenames, &
    srcFilenames, dstFilenames

  ! --------------------------------------------------------------------------------

  call ESMF_Initialize(rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_VMGetGlobal(vm, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! --------------------------------------------------------------------------------
  ! These arrays contain the needed filenames with the file index appended to the
  ! end along with ".nc".

  ii = fileIndexStop - fileIndexStart + 1
  allocate(srcFilenames(ii), dstFilenames(ii), weightFilenames(ii))

  ! --------------------------------------------------------------------------------
  ! Generate the weight files.

  if (verbose .and. (localPet .eq. 0)) then
    if (createWeightFile) then
      print *, 'Generating regridding factors and weight files...'
    else
      print *, 'Skipping weight file creation'
    endif
  endif

  do ii=fileIndexStart,fileIndexStop
    write(srcFilename, *) ii
    write(srcFilename, *) trim(srcFilenameTemplate) // trim(adjustl(srcFilename)) // '.nc'
    srcFilenames(ii) = srcFilename

    write(dstFilename, *) ii
    write(dstFilename, *) trim(dstFilenameTemplate) // trim(adjustl(dstFilename)) // '.nc'
    dstFilenames(ii) = dstFilename

    write(weightFilename, *) ii
    write(weightFilename, *) trim(weightFilenameTemplate) // trim(adjustl(weightFilename)) // '.nc'
    weightFilenames(ii) = weightFilename

    if (ii .ge. skipUntil) then
      if (verbose .and. (localPet .eq. 0) .and. createWeightFile) then
        print *, '     Current Source Filename: ' // trim(srcFilename)
        print *, 'Current Destination Filename: ' // trim(dstFilename)
        print *, '     Current Weight Filename: ' // trim(weightFilename)
        print *, '============================='
      endif

      if (createWeightFile) then
        call ESMF_RegridWeightGen(trim(adjustl(srcFilename)), &
          trim(adjustl(dstFilename)), trim(adjustl(weightFilename)), &
          srcFileType=fileFormat, dstFileType=fileFormat, &
          regridmethod=regridmethod, srcRegionalFlag=.true., &
          dstRegionalFlag=.true., weightOnlyFlag=.true., &
          netcdf4fileFlag=netcdf4fileFlag, unmappedaction=unmappedaction, &
          ignoreDegenerate=ignoreDegenerate, rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      endif
    endif
  enddo

  ! --------------------------------------------------------------------------------
  ! Execute the sparse matrix multiplication.

  if (verbose .and. (localPet .eq. 0)) then
    if (arraySMM) then
      print *, 'Sparse matrix multiplication (weight application)...'
    else
      print *, 'Skipping sparse matrix multiplication (weight application)'
    endif
  endif

  if (arraySMM) then
    do ii=fileIndexStart,fileIndexStop
      if (ii .ge. skipUntil) then

        if (verbose .and. (localPet .eq. 0)) then
          print *, 'Current Weighted Destination Filename: ' // trim(dstFilenames(ii))
        endif

        call ESMF_FileRegridWF(trim(adjustl(srcFilenames(ii))), &
          trim(adjustl(dstFilenames(ii))), srcVarname, dstVarname, &
          trim(adjustl(weightFilenames(ii))), dstFillValue=dstFillValue, rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      endif
    enddo
  endif

  ! --------------------------------------------------------------------------------
  ! Release resources.

  deallocate(srcFilenames, dstFilenames, weightFilenames)

  call ESMF_Finalize()

! ==================================================================================

contains

subroutine ESMF_FileRegridWF(srcFile, dstFile, srcVarname, dstVarname, weightFile, &
  keywordEnforcer, dstFillValue, rc)

  use ESMF
  implicit none

  character(len=*),             intent(in)              :: srcFile
  character(len=*),             intent(in)              :: dstFile
  character(len=*),             intent(in)              :: srcVarName
  character(len=*),             intent(in)              :: dstVarName
  character(len=*),             intent(in)              :: weightFile
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
  real,                         intent(in),    optional :: dstFillValue
  integer,                      intent(inout), optional :: rc

  type(ESMF_Array) :: srcArray, dstArray
  type(ESMF_RouteHandle) :: routehandle
  type(ESMF_DistGrid) :: srcDistGrid, dstDistGrid
  type(ESMF_ArraySpec) :: srcArraySpec, dstArraySpec
  integer, parameter :: defaultRank = 2
  integer, parameter :: timeIndex = 3
  integer :: ncid, ncStatus, ndims, varid, ii, timeCount
  integer, allocatable :: srcVarShp(:), minIndex(:), dstVarShp(:)
  real(ESMF_KIND_R8), pointer :: srcFPtr(:, :), dstFPtr(:, :)
  real :: localDstFillValue

  if (present(rc)) rc = ESMF_RC_NOT_IMPL
  if (present(dstFillValue)) then
    localDstFillValue = dstFillValue
  else
    localDstFillValue = 1e20
  endif

  !---------------------------------------------------------------------------------
  ! Retrieve source and destination variable shapes from their associated netCDF
  ! files.

  ! Source variable shape retrieval.
  call get_variable_shape(srcVarname, srcFile, srcVarShp, rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! The time count is used for the SMM loop.
  timeCount = srcVarShp(timeIndex)

  ! Destination variable shape retrieval.
  call get_variable_shape(dstVarname, dstFile, dstVarShp, rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  !---------------------------------------------------------------------------------
  ! Create the source array and get a pointer to its underlying Fortran data array.

  ! A start/minimum index is used for both the source and destination arrays.
  allocate(minIndex(defaultRank))
  do ii=1,defaultRank
    minIndex(ii) = 1
  enddo

  ! A simple DistGrid is used. The indexing into the shape source variable shape
  ! expects a (time, row/latitude, col/longitude) dimension order which is changed
  ! to (row/latitude, col/longitude, time) by the netCDF Fortran API.
  srcDistGrid = ESMF_DistGridCreate(minIndex, srcVarShp(1:2), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_ArraySpecSet(srcArraySpec, defaultRank, ESMF_TYPEKIND_R8, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  srcArray = ESMF_ArrayCreate(srcDistGrid, srcArraySpec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_ArrayGet(srcArray, farrayPtr=srcFPtr, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! --------------------------------------------------------------------------------
  ! Create the destination array and get a pointer to its underlying Fortran data
  ! array.

  dstDistGrid = ESMF_DistGridCreate(minIndex, dstVarShp(1:2), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_ArraySpecSet(dstArraySpec, defaultRank, ESMF_TYPEKIND_R8, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  dstArray = ESMF_ArrayCreate(dstDistGrid, dstArraySpec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_ArrayGet(dstArray, farrayPtr=dstFPtr, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! --------------------------------------------------------------------------------
  ! Execute the SMM using weights read from file.

  call ESMF_ArraySMMStore(srcArray, dstArray, weightFile, routehandle, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  do ii=1,timeCount
    call ESMF_ArrayRead(srcArray, srcFile, variableName=srcVarName, timeslice=ii, &
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Fill the destination data with the fill value
    dstFptr(:, :) = localDstFillValue

    call ESMF_ArraySMM(srcArray, dstArray, routehandle, zeroregion=zeroregion, &
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_ArrayWrite(dstArray, dstFile, variableName=dstVarName, timeslice=ii, &
      overwrite=.true., rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  enddo

  ! --------------------------------------------------------------------------------
  ! Release resources.

  call ESMF_ArraySMMRelease(routehandle, rc=rc)
  call ESMF_ArrayDestroy(srcArray, rc=rc)
  call ESMF_ArrayDestroy(dstArray, rc=rc)
  call ESMF_DistGridDestroy(srcDistGrid, rc=rc)
  call ESMF_DistGridDestroy(dstDistGrid, rc=rc)

  deallocate(srcVarShp, dstVarShp, minIndex)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

end subroutine ESMF_FileRegridWF

! ==================================================================================

subroutine get_variable_shape(srcVarname, srcFile, varshp, rc)

  use netcdf
  use ESMF_FactorReadMod

  character(len=*), intent(in) :: srcVarname
  character(len=*), intent(in) :: srcFile
  integer, dimension(:), allocatable, intent(out) :: varshp
  integer, intent(inout) :: rc

  character(len=*), parameter :: callingMethod = 'get_variable_shape'
  integer, allocatable :: dimids(:)
  integer :: ncStatus, ncid, varid, ndims, ii

  ncStatus = nf90_open(srcFile, nf90_NoWrite, ncid)
  if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return

  ncStatus = nf90_inq_varid(ncid, srcVarname, varid)
  if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return

  ncStatus = nf90_inquire_variable(ncid, varid, ndims=ndims)
  if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return

  allocate(dimids(ndims), varshp(ndims))

  ncStatus = nf90_inquire_variable(ncid, varid, dimids=dimids)
  if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return

  do ii=1,ndims
    ncStatus = nf90_inquire_dimension(ncid, dimids(ii), len=varshp(ii))
    if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return
  enddo

  ncStatus = nf90_close(ncid)
  if (netcdf_check_error(ncStatus, callingMethod, srcFile, __LINE__, rc)) return

  deallocate(dimids)

end subroutine get_variable_shape

! ==================================================================================

function netcdf_check_error(ncStatus, module, fileName, lineNo, rc)

  logical                        :: netcdf_check_error

  integer, intent(in)            :: ncStatus
  character(len=*), intent(in)   :: module
  character(len=*), intent(in)   :: fileName
  integer, intent(in)  :: lineNo
  integer, intent(out), optional :: rc

  integer, parameter :: nf90_noerror = 0

  netcdf_check_error = .FALSE.

  if (ncStatus .ne. nf90_noerror) then
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
    netcdf_check_error = .TRUE.
  else
    if (present(rc)) rc = ESMF_SUCCESS
  end if

end function netcdf_check_error

! ==================================================================================

end program ESMF_FileRegridWFDemo
